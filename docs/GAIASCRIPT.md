# GaiaScript: Language and Compiler Documentation

GaiaScript is an ultra-compact symbolic programming language designed for maximum density and expressiveness. This document provides a comprehensive overview of the language syntax, compiler architecture, and runtime behavior.

## 1. Introduction

GaiaScript is a domain-specific language built on the philosophy of extreme terseness and symbolic representation. It allows developers to define complex applications, including UI components, 3D graphics, and neural networks, in a single file with minimal character count.

### 1.1 Core Philosophy

- **Extreme Terseness**: Uses symbolic notation for maximum information density
- **Single File Structure**: Entire applications contained in one file
- **Symbolic Representation**: Uses mathematical and special Unicode symbols for operations
- **Cross-Domain Integration**: Unifies UI, 3D graphics, neural networks, and other domains
- **Minimal Runtime**: Designed for small footprint and efficient execution

## 2. Language Syntax

GaiaScript uses a unique symbolic syntax that leverages Unicode characters to represent different components, operations, and data types.

### 2.1 Basic Structure

A GaiaScript program typically starts with a network declaration that defines the main components:

```
N〈γ⊕φ⊕δ⊕α〉
```

Where:
- `N` indicates a network/application declaration
- `〈...〉` groups related components
- `⊕` connects/composes components
- Greek letters (`γ`, `φ`, `δ`, `α`) represent different component domains:
  - `γ`: UI components
  - `φ`: Game/3D engine
  - `δ`: Neural networks/Data processing
  - `α`: Assets/Resources

### 2.2 Component Definitions

Components are defined using the format `id:expression`:

```
γ:H→∮800×600→П→⊞3×3→[(⌘"▶"⌘click→φ.①),(⌘"↺"⌘click→φ.⓪),(⌑"§"⇄φ.ς)]
```

Where:
- `γ` is the component identifier
- `:` separates the identifier from the implementation
- `→` indicates data flow/sequence of operations
- Specialized symbols represent different UI elements (`∮` for canvas, `П` for panel, etc.)

### 2.3 Data Flow

Operations are chained using the data flow operator `→`:

```
I224×224×3→C₁32→P→C₂64→P→F→D₁128→D₂64→D₀10→S
```

This represents a sequence of transformations, where each operation receives input from the previous one.

### 2.4 Symbol Categories

#### 2.4.1 UI Components
- `∮`: Canvas (with optional dimensions)
- `П`: Panel/Container
- `⊞`: Grid layout (with optional dimensions)
- `⌘`: Button
- `⌑`: Label/Text

#### 2.4.2 Events and Bindings
- `⌘click→`: Click event handler
- `⇄`: Data binding

#### 2.4.3 Neural Network Layers
- `I`: Image input
- `T`: Text input
- `Z`: Latent vector input
- `C₁`: Convolutional layer
- `D₁`: Dense layer
- `P`: Pooling layer
- `F`: Flatten layer
- `S`: Softmax activation

#### 2.4.4 3D Components
- `⦿`: 3D World
- `⌖`: Camera
- `⟲`: Renderer
- `⊿`: 3D Mesh
- `⍉`: Texture
- `◐`: Material
- `⌼`: Shader
- `☀`: Light
- `⊠`: Skybox
- `⊛`: Scene

### 2.5 GaiaUI Extensions

GaiaScript includes extensions for UI component development with the GaiaUI framework:

```
C〈counter〉counter:⟨{
  state:⟨count:0⟩, 
  style:⟨
    container:⟨padding:20px, align:center⟩,
    button:⟨color:#fff, background:#336, width:40px⟩,
    value:⟨fontSize:24px, color:#222⟩
  ⟩,
  render:⟨
    П→⊞3×1→[
      (⌘"-"⌘click→count⊝),
      (⌑"Count: ${count}"⇄count),
      (⌘"+"⌘click→count⊕)
    ]
  ⟩
}⟩
```

This syntax defines:
- Component state (`count:0`)
- Component styles
- Rendering logic with event handlers and data binding

## 3. Compiler Architecture

The GaiaScript compiler is implemented in Rust and follows a multi-stage compilation process.

### 3.1 Parsing Stage

The parser uses the Pest parser generator to transform GaiaScript code into an Abstract Syntax Tree (AST). The grammar is defined in `aopl.pest` which specifies the rules for all symbolic operations.

Key components:
- `AoplParser`: The main parser generated by Pest
- Grammar rules defined in `aopl.pest`
- `parse()` function that converts input text to AST

### 3.2 Abstract Syntax Tree (AST)

The AST is defined in `ast.rs` and contains node types for different language constructs:

```rust
pub enum ASTNode {
    Network(NetworkNode),
    Component(ComponentNode),
    Layer(LayerNode),
    Block(BlockNode),
    Input(InputNode),
    DataFlow(Box<ASTNode>, Box<ASTNode>),
    Loss(LossNode),
    Expression(Vec<ASTNode>),
    UIComponent(UIComponentNode),
    EventHandler(EventHandlerNode),
    DataBinding(DataBindingNode),
    ThreeDComponent(ThreeDComponentNode),
    Asset(AssetNode),
}
```

### 3.3 Compilation Stage

The compiler processes the AST to generate target code. It can produce different outputs:

1. **JS/HTML/CSS**: For web applications
2. **JavaScript with Native Bridges**: For iOS/Mac applications using JavaScriptCore
3. **WebAssembly**: For high-performance web applications
4. **Native Code**: Through assembly generation

### 3.4 Target-Specific Compilation

#### 3.4.1 Web Target

For web applications, the compiler generates:
- HTML structure for UI components
- CSS for styling
- JavaScript for state management and event handling

#### 3.4.2 Native Platforms

For native platforms like iOS:
- JavaScript code for the core logic
- Native bridge code (Swift, C#) for UI rendering
- Interfacing with platform-specific APIs

### 3.5 Symbol Table

The compiler maintains a symbol table to resolve component references:

```rust
pub struct SymbolTable {
    pub components: HashMap<String, ASTNode>,
}
```

This allows components to reference other components by name.

## 4. Runtime Behavior

GaiaScript code is executed in different environments depending on the compilation target.

### 4.1 Web Runtime

In web environments, GaiaScript compiles to a minimal runtime with three core functions:

1. `createElement (e)`: Creates DOM elements with attributes and event listeners
2. `render (r)`: Mounts components to a container
3. `createStore (s)`: Manages reactive state with subscriptions

The total minified runtime is approximately 1KB.

### 4.2 Reactive State Management

GaiaScript implements a simple reactive state system:

```javascript
function createStore(initialState) {
  let state = initialState;
  let subscribers = [];
  
  return {
    get: () => state,
    set: (newState) => {
      state = {...state, ...newState};
      subscribers.forEach(fn => fn());
    },
    subscribe: (fn) => subscribers.push(fn)
  };
}
```

State changes automatically trigger UI updates through subscription mechanisms.

### 4.3 Native Platform Bridges

#### 4.3.1 iOS/Mac Bridge

For iOS and Mac applications, GaiaScript uses JavaScriptCore to evaluate code, with a Swift bridge converting JavaScript UI descriptions to native UIKit components:

```swift
import JavaScriptCore

class GaiaUIBridge {
    let context = JSContext()!
    let rootView: UIView
    
    init(rootView: UIView) {
        self.rootView = rootView
        setupBridge()
    }
    
    func setupBridge() {
        // Map JavaScript functions to Swift
        context.setObject(self, forKeyedSubscript: "nativeBridge" as NSString)
    }
    
    func renderComponent(componentJS: String) {
        context.evaluateScript(componentJS)
    }
    
    @objc func createView(_ descriptor: [String: Any]) -> UIView {
        // Convert JS descriptor to UIKit view
        // Return the created view
    }
}
```

#### 4.3.2 Windows Bridge

For Windows applications, GaiaScript can use either:
- WebView2 for web-based rendering
- Direct JavaScript-to-WPF/WinUI bridges via JavaScript engines like V8

### 4.4 Optimization Techniques

The GaiaScript runtime employs several optimization techniques:

1. **Minimal JavaScript**: Uses HTML and CSS for structure and styling whenever possible
2. **Direct DOM Manipulation**: Avoids virtual DOM overhead
3. **Event Delegation**: Uses event delegation for efficient event handling
4. **Lazy Rendering**: Components are only rendered when needed
5. **Targeted Updates**: Only updates DOM elements affected by state changes

## 5. Integration Capabilities

GaiaScript can integrate with external systems and frameworks.

### 5.1 Web Integration

```html
<!-- Include GaiaScript runtime -->
<script src="gaia-runtime.min.js"></script>

<!-- Container for GaiaScript app -->
<div id="app"></div>

<script>
  // Load and run compiled GaiaScript
  fetch('app.gaia.js')
    .then(res => res.text())
    .then(code => eval(code));
</script>
```

### 5.2 iOS/Mac Integration

```swift
// In your UIViewController
let containerView = UIView(frame: view.bounds)
view.addSubview(containerView)

let bridge = GaiaUIBridge(rootView: containerView)
bridge.renderComponent(compiledJS)
```

### 5.3 Neural Network Integration

GaiaScript can define neural network architectures that integrate with frameworks like TensorFlow.js:

```
N〈δ〉δ:I224×224×3→C₁32→P→C₂64→P→F→D₁128→D₂64→D₀10→S
```

This can compile to TensorFlow.js code for execution.

## 6. Extension Mechanism

GaiaScript is designed to be extensible through its compiler.

### 6.1 Adding New Symbols

New symbols can be added by:
1. Defining new rules in `aopl.pest`
2. Adding corresponding AST nodes
3. Implementing compiler handlers for the new nodes

### 6.2 Custom Compilers

The system supports custom compilers through the `compilers/` directory, allowing for specialized compilation targets.

### 6.3 Language Extensions

Extended syntax can be added for specific domains:
- UI extensions for new component types
- Machine learning extensions for new layer types
- 3D extensions for new graphics capabilities

## 7. Examples

### 7.1 Minimal UI Framework Definition

```
// GaiaUI Framework Definition
UI〈γ〉γ:C→P→L→S→R→B→E
```

### 7.2 Counter Component

```
C〈δ〉δ:⟨{
  state:⟨count:0⟩, 
  style:⟨
    container:⟨padding:20px, align:center, display:flex, flexDirection:column⟩,
    button:⟨color:#fff, background:#336, margin:5px, width:40px, borderRadius:4px, fontSize:18px⟩,
    value:⟨fontSize:24px, color:#222, margin:10px, fontWeight:bold⟩
  ⟩,
  render:⟨
    П→⊞3×1→[
      (⌘"-"⌘click→count⊝),
      (⌑"Count: ${count}"⇄count),
      (⌘"+"⌘click→count⊕)
    ]
  ⟩
}⟩
```

### 7.3 Complete UI Framework

```
UI〈§⊕γ⊕δ〉

// State Store Component
§:Σ→⍚→⚡→Ω

// UI Component System
γ:⟨{state, style, render}⟩→∮→П→⊞→⌘→⌑→⇄→@

// Counter Example Component
δ:⟨{
  state:⟨count:0⟩, 
  style:⟨
    container:⟨padding:20px, align:center⟩,
    button:⟨color:#336, margin:5px, width:40px⟩,
    value:⟨fontSize:24px, color:#222⟩
  ⟩,
  render:⟨
    П→⊞2×1→[
      (⌘"-"⌘click→count⊝),
      (⌑"${count}"⇄count),
      (⌘"+"⌘click→count⊕)
    ]
  ⟩
}⟩
```

### 7.4 Neural Network Definition

```
N〈δ〉δ:I224×224×3→C₁32→P→C₂64→P→F→D₁128→D₂64→D₀10→S
```

## 8. Running GaiaScript

### 8.1 Development Environment

To run GaiaScript code:

1. Install the compiler (requires Rust):
   ```bash
   git clone https://github.com/yourusername/gaiascript.git
   cd gaiascript
   cargo build --release
   ```

2. Compile and serve GaiaScript code:
   ```bash
   cargo run -- serve main.gaia
   ```

3. Open in a browser:
   ```
   http://localhost:8080/unified/
   ```

### 8.2 Command Line Interface

The GaiaScript compiler provides several CLI commands:

- `compile <file>`: Compile to JavaScript
- `serve <file>`: Compile and serve as a web application
- `build <file>`: Create a deployable bundle
- `test <file>`: Run tests on GaiaScript code

## 9. Conclusion

GaiaScript represents a unique approach to programming that prioritizes extreme terseness through symbolic representation. Its compiler architecture enables cross-platform deployment from a single codebase, while the runtime system provides efficient execution through targeted optimizations.

The language is particularly well-suited for:
- AI-generated code where token efficiency is crucial
- Rapid prototyping of cross-platform applications
- Defining neural network architectures in minimal space
- Creating UI components with minimal overhead

By combining symbolic notation with powerful compilation techniques, GaiaScript achieves a balance between human readability and machine efficiency, offering a novel approach to software development for specialized domains.