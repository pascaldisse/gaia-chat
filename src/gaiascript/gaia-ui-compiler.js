/**
 * GaiaUI Compiler
 * Converts GaiaScript code to JavaScript, HTML, and CSS
 */

/**
 * Main function to compile a GaiaScript file to web components
 * @param {string} source - The GaiaScript source code
 * @returns {Object} - Object containing compiled HTML, CSS, and JS
 */
function compileGaiaScript(source) {
  // Parse the source code into AST
  const ast = parseGaiaScript(source);
  
  // Generate code from AST for different targets
  return {
    web: {
      html: generateHTML(ast),
      css: generateCSS(ast),
      js: generateJS(ast)
    },
    ios: {
      swift: generateSwift(ast),
      js: generateIOSBridgeJS(ast)
    },
    win: {
      csharp: generateCSharp(ast)
    }
  };
}

/**
 * Parse GaiaScript code into an AST
 * @param {string} source - The GaiaScript source code
 * @returns {Object} - The AST representing the code
 */
function parseGaiaScript(source) {
  // This is a simplified parser for demonstration
  // In a real implementation, this would be much more complex
  
  // Identify component definitions (C〈id〉id:⟨{...}⟩)
  const componentRegex = /C〈([^〉]+)〉([^:]+)[:](⟨\{[\s\S]*?\}⟩)/g;
  const components = [];
  
  let match;
  while ((match = componentRegex.exec(source)) !== null) {
    const [_, id, name, body] = match;
    
    // Extract component sections
    const stateSectionRegex = /state[:](⟨[\s\S]*?⟩)/;
    const styleSectionRegex = /style[:](⟨[\s\S]*?⟩)/;
    const renderSectionRegex = /render[:](⟨[\s\S]*?⟩)/;
    const methodsSectionRegex = /methods[:](⟨[\s\S]*?⟩)/;
    const propsSectionRegex = /props[:](⟨[\s\S]*?⟩)/;
    
    const stateMatch = body.match(stateSectionRegex);
    const styleMatch = body.match(styleSectionRegex);
    const renderMatch = body.match(renderSectionRegex);
    const methodsMatch = body.match(methodsSectionRegex);
    const propsMatch = body.match(propsSectionRegex);
    
    components.push({
      id,
      name,
      state: stateMatch ? parseSection(stateMatch[1]) : {},
      props: propsMatch ? parseSection(propsMatch[1]) : {},
      style: styleMatch ? parseSection(styleMatch[1]) : {},
      render: renderMatch ? renderMatch[1] : '',
      methods: methodsMatch ? parseSection(methodsMatch[1]) : {}
    });
  }
  
  // Identify UI framework definition (UI〈§⊕γ⊕δ〉)
  const uiFrameworkRegex = /UI〈([^〉]+)〉([\s\S]*?)(?=C〈|$)/;
  const uiMatch = source.match(uiFrameworkRegex);
  
  let framework = null;
  if (uiMatch) {
    const [_, components, body] = uiMatch;
    
    // Extract framework sections (§:, γ:, δ:)
    const storeSectionRegex = /§[:]([\s\S]*?)(?=γ:|δ:|$)/;
    const frameworkUiSectionRegex = /γ[:]([\s\S]*?)(?=§:|δ:|$)/;
    const appSectionRegex = /δ[:]([\s\S]*?)(?=§:|γ:|$)/;
    
    const storeMatch = body.match(storeSectionRegex);
    const frameworkUiMatch = body.match(frameworkUiSectionRegex);
    const appMatch = body.match(appSectionRegex);
    
    framework = {
      components: components.split('⊕'),
      store: storeMatch ? storeMatch[1] : '',
      ui: frameworkUiMatch ? parseSection(frameworkUiMatch[1]) : {},
      app: appMatch ? parseSection(appMatch[1]) : {}
    };
  }
  
  return {
    components,
    framework
  };
}

/**
 * Parse a GaiaScript section (contents between ⟨⟩)
 * @param {string} section - The section content
 * @returns {Object} - Parsed object representing the section
 */
function parseSection(section) {
  // Remove delimiters ⟨⟩
  section = section.replace(/^⟨|\⟩$/g, '');
  
  // This is a simplified parser - in a real implementation,
  // this would handle all the complex syntax of GaiaScript
  
  // For demonstration, return a placeholder object
  return { __raw: section };
}

/**
 * Generate HTML from AST
 * @param {Object} ast - The AST
 * @returns {string} - Generated HTML
 */
function generateHTML(ast) {
  const { components } = ast;
  
  // For simplicity, we're generating a basic structure
  // In a real implementation, this would interpret the render sections
  
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GaiaUI App</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="app"></div>
  <script src="gaia-ui-runtime.js"></script>
  <script src="app.js"></script>
</body>
</html>`;
  
  return html;
}

/**
 * Generate CSS from AST
 * @param {Object} ast - The AST
 * @returns {string} - Generated CSS
 */
function generateCSS(ast) {
  const { components, framework } = ast;
  
  let css = `/* Generated by GaiaUI Compiler */\n\n`;
  
  // Add global styles if framework is defined
  if (framework && framework.ui.__raw) {
    css += `/* Framework styles */\n`;
    css += `:root {\n`;
    css += `  --primary-color: #0084ff;\n`;
    css += `  --secondary-color: #f5f5f5;\n`;
    css += `  --text-color: #333333;\n`;
    css += `  --border-radius: 20px;\n`;
    css += `}\n\n`;
    
    css += `body {\n`;
    css += `  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n`;
    css += `  margin: 0;\n`;
    css += `  padding: 0;\n`;
    css += `  color: var(--text-color);\n`;
    css += `}\n\n`;
    
    css += `#app {\n`;
    css += `  height: 100vh;\n`;
    css += `  width: 100%;\n`;
    css += `}\n\n`;
  }
  
  // Add component styles
  components.forEach(component => {
    css += `/* ${component.name} component styles */\n`;
    
    if (component.style.__raw) {
      // Process component styles from raw data
      // This is a simplified version - in a real implementation,
      // we would parse the style objects and generate proper CSS
      
      // For example, if we had container:⟨display:flex, padding:20px⟩
      css += `.${component.name}-container {\n`;
      css += `  display: flex;\n`;
      css += `  flex-direction: column;\n`;
      css += `  padding: 20px;\n`;
      css += `}\n\n`;
      
      // Add more styles based on component type
      if (component.name === 'chat') {
        css += `.messages {\n`;
        css += `  flex: 1;\n`;
        css += `  overflow-y: auto;\n`;
        css += `  padding: 20px;\n`;
        css += `  background-color: var(--secondary-color);\n`;
        css += `}\n\n`;
        
        css += `.message {\n`;
        css += `  margin: 10px 0;\n`;
        css += `  padding: 10px;\n`;
        css += `  border-radius: 18px;\n`;
        css += `  max-width: 80%;\n`;
        css += `}\n\n`;
        
        css += `.user-message {\n`;
        css += `  background-color: var(--primary-color);\n`;
        css += `  color: white;\n`;
        css += `  align-self: flex-end;\n`;
        css += `  margin-left: auto;\n`;
        css += `}\n\n`;
        
        css += `.ai-message {\n`;
        css += `  background-color: white;\n`;
        css += `  color: var(--text-color);\n`;
        css += `  align-self: flex-start;\n`;
        css += `  box-shadow: 0 1px 2px rgba(0,0,0,0.1);\n`;
        css += `}\n\n`;
        
        css += `.input-container {\n`;
        css += `  display: flex;\n`;
        css += `  padding: 10px;\n`;
        css += `  border-top: 1px solid #e6e6e6;\n`;
        css += `  background-color: white;\n`;
        css += `}\n\n`;
        
        css += `textarea {\n`;
        css += `  flex: 1;\n`;
        css += `  padding: 12px;\n`;
        css += `  border-radius: 20px;\n`;
        css += `  border: 1px solid #e6e6e6;\n`;
        css += `  resize: none;\n`;
        css += `  font-size: 14px;\n`;
        css += `  outline: none;\n`;
        css += `}\n\n`;
        
        css += `textarea:focus {\n`;
        css += `  border-color: var(--primary-color);\n`;
        css += `}\n\n`;
        
        css += `button {\n`;
        css += `  padding: 8px 16px;\n`;
        css += `  background-color: var(--primary-color);\n`;
        css += `  color: white;\n`;
        css += `  border: none;\n`;
        css += `  border-radius: 20px;\n`;
        css += `  margin-left: 10px;\n`;
        css += `  cursor: pointer;\n`;
        css += `}\n\n`;
        
        css += `button:disabled {\n`;
        css += `  opacity: 0.6;\n`;
        css += `  cursor: not-allowed;\n`;
        css += `}\n\n`;
      }
    }
  });
  
  return css;
}

/**
 * Generate JavaScript from AST
 * @param {Object} ast - The AST
 * @returns {string} - Generated JavaScript
 */
function generateJS(ast) {
  const { components, framework } = ast;
  
  let js = `// Generated by GaiaUI Compiler\n\n`;
  
  // Add component definitions
  components.forEach(component => {
    js += `// ${component.name} component\n`;
    js += `const ${component.name}Config = {\n`;
    
    // Add state
    js += `  state: {\n`;
    js += `    // State properties would be parsed from: ${JSON.stringify(component.state.__raw)}\n`;
    if (component.name === 'chat') {
      js += `    messages: [],\n`;
      js += `    isLoading: false,\n`;
      js += `    inputValue: "",\n`;
      js += `    isCancelled: false,\n`;
      js += `    showSuggestions: false,\n`;
      js += `    filteredSuggestions: [],\n`;
      js += `    mentionStartIndex: null,\n`;
      js += `    selectedSuggestionIndex: 0,\n`;
      js += `    webSearchEnabled: false\n`;
    } else if (component.name === 'message') {
      js += `    showActions: false\n`;
    } else if (component.name === 'chatInput') {
      js += `    inputValue: "",\n`;
      js += `    showSuggestions: false,\n`;
      js += `    filteredSuggestions: [],\n`;
      js += `    mentionStartIndex: null,\n`;
      js += `    selectedSuggestionIndex: 0,\n`;
      js += `    webSearchEnabled: false\n`;
    }
    js += `  },\n`;
    
    // Add methods
    js += `  methods: {\n`;
    js += `    // Methods would be parsed from: ${JSON.stringify(component.methods.__raw)}\n`;
    
    // Add some sample methods based on component type
    if (component.name === 'chat') {
      js += `    handleSubmit() {\n`;
      js += `      if (!this.inputValue.trim()) return;\n`;
      js += `      \n`;
      js += `      // Add user message\n`;
      js += `      this.updateState(state => ({\n`;
      js += `        messages: [...state.messages, {\n`;
      js += `          id: Date.now(),\n`;
      js += `          content: state.inputValue,\n`;
      js += `          isUser: true\n`;
      js += `        }],\n`;
      js += `        inputValue: "",\n`;
      js += `        isLoading: true\n`;
      js += `      }));\n`;
      js += `      \n`;
      js += `      // Simulate AI response\n`;
      js += `      setTimeout(() => {\n`;
      js += `        this.updateState(state => ({\n`;
      js += `          messages: [...state.messages, {\n`;
      js += `            id: Date.now(),\n`;
      js += `            content: this.getAIResponse(state.messages[state.messages.length - 1].content),\n`;
      js += `            isUser: false,\n`;
      js += `            personaId: "1"\n`;
      js += `          }],\n`;
      js += `          isLoading: false\n`;
      js += `        }));\n`;
      js += `      }, 1000);\n`;
      js += `    },\n`;
      js += `    \n`;
      js += `    getAIResponse(userInput) {\n`;
      js += `      const responses = [\n`;
      js += `        "I understand your question about " + userInput.substring(0, 20) + "...",\n`;
      js += `        "That's an interesting point about " + userInput.substring(0, 15) + "...",\n`;
      js += `        "Let me think about " + userInput.substring(0, 10) + "...",\n`;
      js += `        "I'd be happy to help with " + userInput.substring(0, 25) + "..."\n`;
      js += `      ];\n`;
      js += `      return responses[Math.floor(Math.random() * responses.length)];\n`;
      js += `    }\n`;
    } else if (component.name === 'message') {
      js += `    handleCopy() {\n`;
      js += `      navigator.clipboard.writeText(this.content)\n`;
      js += `        .then(() => {\n`;
      js += `          alert("Copied to clipboard!");\n`;
      js += `        })\n`;
      js += `        .catch(err => {\n`;
      js += `          console.error("Failed to copy: ", err);\n`;
      js += `        });\n`;
      js += `      \n`;
      js += `      this.updateState({ showActions: false });\n`;
      js += `    },\n`;
      js += `    \n`;
      js += `    handleMouseEnter() {\n`;
      js += `      this.updateState({ showActions: true });\n`;
      js += `    },\n`;
      js += `    \n`;
      js += `    handleMouseLeave() {\n`;
      js += `      this.updateState({ showActions: false });\n`;
      js += `    }\n`;
    } else if (component.name === 'chatInput') {
      js += `    handleInput(e) {\n`;
      js += `      this.updateState({ inputValue: e.target.value });\n`;
      js += `    },\n`;
      js += `    \n`;
      js += `    handleKeyDown(e) {\n`;
      js += `      if (e.key === 'Enter' && !e.shiftKey) {\n`;
      js += `        e.preventDefault();\n`;
      js += `        if (this.onSendMessage) {\n`;
      js += `          this.onSendMessage(this.inputValue);\n`;
      js += `          this.updateState({ inputValue: "" });\n`;
      js += `        }\n`;
      js += `      }\n`;
      js += `    }\n`;
    }
    js += `  },\n`;
    
    // Add render function
    js += `  render() {\n`;
    js += `    // Render would be parsed from: ${component.render}\n`;
    
    // Add component-specific rendering
    if (component.name === 'chat') {
      js += `    return GaiaUI.createElement('div', { className: 'chat-container' },\n`;
      js += `      GaiaUI.createElement('div', { className: 'messages' },\n`;
      js += `        this.messages.map(message => {\n`;
      js += `          return GaiaUI.createElement('div', { \n`;
      js += `            className: message.isUser ? 'message user-message' : 'message ai-message',\n`;
      js += `            key: message.id\n`;
      js += `          }, message.content);\n`;
      js += `        })\n`;
      js += `      ),\n`;
      js += `      GaiaUI.createElement('div', { className: 'input-container' },\n`;
      js += `        GaiaUI.createElement('textarea', {\n`;
      js += `          placeholder: 'Type your message...',\n`;
      js += `          value: this.inputValue,\n`;
      js += `          oninput: this.handleInput,\n`;
      js += `          onkeydown: this.handleKeyDown,\n`;
      js += `          disabled: this.isLoading\n`;
      js += `        }),\n`;
      js += `        GaiaUI.createElement('button', {\n`;
      js += `          onclick: this.handleSubmit,\n`;
      js += `          disabled: this.isLoading\n`;
      js += `        }, 'Send')\n`;
      js += `      )\n`;
      js += `    );\n`;
    } else if (component.name === 'message') {
      js += `    return GaiaUI.createElement('div', {\n`;
      js += `      className: this.isUser ? 'message user-message' : 'message ai-message',\n`;
      js += `      onmouseenter: this.handleMouseEnter,\n`;
      js += `      onmouseleave: this.handleMouseLeave\n`;
      js += `    }, this.content);\n`;
    } else if (component.name === 'chatInput') {
      js += `    return GaiaUI.createElement('div', { className: 'chat-input' },\n`;
      js += `      GaiaUI.createElement('textarea', {\n`;
      js += `        placeholder: 'Type your message...',\n`;
      js += `        value: this.inputValue,\n`;
      js += `        oninput: this.handleInput,\n`;
      js += `        onkeydown: this.handleKeyDown,\n`;
      js += `        disabled: this.isLoading\n`;
      js += `      }),\n`;
      js += `      GaiaUI.createElement('button', {\n`;
      js += `        onclick: () => {\n`;
      js += `          if (this.onSendMessage) {\n`;
      js += `            this.onSendMessage(this.inputValue);\n`;
      js += `            this.updateState({ inputValue: "" });\n`;
      js += `          }\n`;
      js += `        },\n`;
      js += `        disabled: this.isLoading\n`;
      js += `      }, 'Send')\n`;
      js += `    );\n`;
    } else {
      js += `    return GaiaUI.createElement('div', {}, 'Component: ${component.name}');\n`;
    }
    js += `  }\n`;
    js += `};\n\n`;
  });
  
  // Initialize the app
  js += `// Initialize app\n`;
  js += `document.addEventListener('DOMContentLoaded', () => {\n`;
  js += `  const app = GaiaUI.createElement('div', { className: 'app-container' },\n`;
  js += `    GaiaUI.createComponent(chatConfig)\n`;
  js += `  );\n`;
  js += `  GaiaUI.render(app, '#app');\n`;
  js += `});\n`;
  
  return js;
}

/**
 * Generate Swift bridge code for iOS/Mac
 * @param {Object} ast - The AST
 * @returns {string} - Generated Swift code
 */
function generateSwift(ast) {
  return `import UIKit
import JavaScriptCore

class GaiaUIBridge {
    let context: JSContext
    let rootView: UIView
    
    init(rootView: UIView) {
        self.rootView = rootView
        self.context = JSContext()!
        setupBridge()
    }
    
    func setupBridge() {
        // Expose native functions to JavaScript
        context.setObject(self, forKeyedSubscript: "nativeBridge" as NSString)
        
        // Load the GaiaUI runtime
        if let runtimePath = Bundle.main.path(forResource: "gaia-ui-runtime", ofType: "js"),
           let runtimeJS = try? String(contentsOfFile: runtimePath, encoding: .utf8) {
            context.evaluateScript(runtimeJS)
        }
    }
    
    func renderComponent(componentJS: String) {
        context.evaluateScript(componentJS)
    }
    
    @objc func createNativeView(_ type: String, properties: [String: Any]) -> UIView {
        // Create appropriate UIKit component based on type
        switch type {
            case "div":
                let view = UIView()
                applyCommonProperties(view, properties: properties)
                return view
                
            case "button":
                let button = UIButton(type: .system)
                if let title = properties["text"] as? String {
                    button.setTitle(title, for: .normal)
                }
                applyCommonProperties(button, properties: properties)
                return button
                
            case "textarea", "input":
                let textField = UITextField()
                if let placeholder = properties["placeholder"] as? String {
                    textField.placeholder = placeholder
                }
                if let value = properties["value"] as? String {
                    textField.text = value
                }
                applyCommonProperties(textField, properties: properties)
                return textField
                
            case "label", "span", "p":
                let label = UILabel()
                if let text = properties["text"] as? String {
                    label.text = text
                }
                if let fontSize = properties["fontSize"] as? CGFloat {
                    label.font = UIFont.systemFont(ofSize: fontSize)
                }
                applyCommonProperties(label, properties: properties)
                return label
                
            default:
                return UIView()
        }
    }
    
    private func applyCommonProperties(_ view: UIView, properties: [String: Any]) {
        if let backgroundColor = properties["backgroundColor"] as? String {
            view.backgroundColor = UIColor(hex: backgroundColor)
        }
        
        if let cornerRadius = properties["borderRadius"] as? CGFloat {
            view.layer.cornerRadius = cornerRadius
        }
    }
    
    @objc func setViewProperty(_ view: UIView, property: String, value: Any) {
        // Set property on UIKit component
    }
    
    @objc func addEventHandler(_ view: UIView, event: String, handlerID: String) {
        // Connect event to JavaScript callback
    }
}

// Helper extension to convert hex colors
extension UIColor {
    convenience init(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
        
        var rgb: UInt64 = 0
        
        Scanner(string: hexSanitized).scanHexInt64(&rgb)
        
        let red = CGFloat((rgb & 0xFF0000) >> 16) / 255.0
        let green = CGFloat((rgb & 0x00FF00) >> 8) / 255.0
        let blue = CGFloat(rgb & 0x0000FF) / 255.0
        
        self.init(red: red, green: green, blue: blue, alpha: 1.0)
    }
}`;
}

/**
 * Generate iOS bridge JavaScript
 * @param {Object} ast - The AST
 * @returns {string} - Generated JavaScript for iOS bridge
 */
function generateIOSBridgeJS(ast) {
  return `// GaiaUI iOS Bridge

// Create a native UIView
function createNativeView(type, props = {}) {
  const view = nativeBridge.createNativeView(type, props);
  view._nativeView = true;
  view._type = type;
  view._props = props;
  
  return view;
}

// Set a property on a native view
function setViewProperty(view, property, value) {
  if (view._nativeView) {
    nativeBridge.setViewProperty(view, property, value);
  }
}

// Add an event handler to a native view
function addEventHandler(view, event, handler) {
  if (view._nativeView) {
    const handlerId = 'handler_' + Math.random().toString(36).substr(2, 9);
    nativeBridge.addEventHandler(view, event, handlerId);
    
    // Store handler in global registry
    window._eventHandlers = window._eventHandlers || {};
    window._eventHandlers[handlerId] = handler;
  }
}

// Override the createElement function to use native views
const originalCreateElement = GaiaUI.createElement;
GaiaUI.createElement = function(type, props = {}, ...children) {
  // Check if we're in native environment
  if (typeof nativeBridge !== 'undefined') {
    const view = createNativeView(type, props);
    
    // Handle event props
    for (const [key, value] of Object.entries(props)) {
      if (key.startsWith('on') && typeof value === 'function') {
        const eventName = key.substr(2).toLowerCase();
        addEventHandler(view, eventName, value);
      }
    }
    
    // Add children
    children.forEach(child => {
      if (typeof child === 'string') {
        const textView = createNativeView('label', { text: child });
        nativeBridge.addSubview(view, textView);
      } else if (child._nativeView) {
        nativeBridge.addSubview(view, child);
      }
    });
    
    return view;
  }
  
  // Fall back to web implementation
  return originalCreateElement(type, props, ...children);
};`;
}

/**
 * Generate C# code for Windows bridge
 * @param {Object} ast - The AST
 * @returns {string} - Generated C# code
 */
function generateCSharp(ast) {
  return `using System;
using Microsoft.Web.WebView2.Core;
using Microsoft.Web.WebView2.WinForms;

namespace GaiaUI.Windows
{
    public class GaiaUIBridge
    {
        private WebView2 webView;
        
        public GaiaUIBridge(WebView2 webView)
        {
            this.webView = webView;
            SetupBridge();
        }
        
        private async void SetupBridge()
        {
            await webView.EnsureCoreWebView2Async();
            
            // Add bridge object for JavaScript to call into C#
            webView.CoreWebView2.AddHostObjectToScript("nativeBridge", this);
            
            // Load GaiaUI runtime
            string runtimeJS = LoadRuntimeJS();
            await webView.CoreWebView2.ExecuteScriptAsync(runtimeJS);
        }
        
        private string LoadRuntimeJS()
        {
            // Load from embedded resource or file
            return "// GaiaUI Runtime would be loaded here";
        }
        
        public void RenderComponent(string componentJS)
        {
            webView.CoreWebView2.ExecuteScriptAsync(componentJS);
        }
        
        // Methods exposed to JavaScript
        public string CreateNativeWindow(string type, string propertiesJson)
        {
            // In WebView2, we're using HTML rendering instead of native controls
            // So this is mostly a pass-through that returns a unique ID
            return Guid.NewGuid().ToString();
        }
    }
}`;
}

// Export the compiler functions if running in Node.js
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    compileGaiaScript,
    parseGaiaScript,
    generateHTML,
    generateCSS,
    generateJS,
    generateSwift,
    generateIOSBridgeJS,
    generateCSharp
  };
}